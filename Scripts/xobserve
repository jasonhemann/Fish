#! /bin/sh
#| -*- racket -*-
exec racket -tm "$0" -- ${1+"$@"}
|#
#lang racket

;; TODO:
;; parse-arg should return either a number of players or a list of files ptrs
;; design `make-players` which takes either a number or a list and works from there.
;;      it returns names and player objects 

;; usage:
;; ./xobserve --file path-to-file.json 
;;
;; xor
;; 
;; ./xobserve fish = F players = P rows = R columns = C
;; for F, P, R, C and D in Naturals
;; The command line may specify these parameters in any order, abd every field is optional.
;; 
;; example: 
;; ./xobserve fish=5 players = 4 row = 2 columns = 9 

;; main n:natural runs a game with n AI players and one human controled player, plus one observer 

(provide main)

;; ---------------------------------------------------------------------------------------------------
(require Fish/Admin/referee)
(require Fish/Admin/game-observer)
(require Fish/Common/game-state)
(require Fish/Player/player)
(require Fish/Player/greedy)
(require Fish/Player/human)

(require json)

;; ---------------------------------------------------------------------------------------------------
(define (main . n)
  (define-values (players names rows cols fish) (configure n))
  (define state0  (create-state rows cols players #:fixed fish))
  (match-define (list rankings failures) (referee state0 #:time-out 5 #:observers (list observer)))

  (report-results names players rankings failures))

#; {[Listof String] -> (values [Listof Player] [Listof String] N N N)}
(define (configure n)
  (define-values (raws rows cols fish) (parse-args n))
  (cond
    [(number? raws)
     (define names (take '("Benjamin" "Aria" "Emma" "Rachel") raws))
     (define plers (map (λ (n) (new player% [strategy (new greedy-strategy)])) names))
     (who-s-playing 'greedy names)
     (values plers names rows cols fish)]
    [else
     (define names (take '("Benjamin" "Aria" "Emma" "Rachel") (length raws)))
     (define strts (map (λ (s) (new (dynamic-require s 'strategy%))) raws))
     (define plers (map (λ (s) (new player% [strategy s])) strts))
     (who-s-playing strts names)
     (values plers names rows cols fish)]))

#; { (U Symbol [Listof FilePath]) [Listof String] -> Void}
(define (who-s-playing strts names)
  (displayln `[The following players are competing])
  (if (symbol? strts)
      (for-each displayln (map (λ (n) `[,n with ,(object-name strts)]) names))
      (for-each displayln (map (λ (n s) `[,n with ,(object-name s)]) names strts))))


#; {[Listof String] [Listof [Listof [Instanceof Player]]] [Listof [Instanceof Player]] -> Void}
(define (report-results names players rankings failures)
  (for ([f failures]) (displayln `[,(match-name names players f) failed or cheated]))
  (for ([r rankings] [p (in-naturals)])
    (for ([a-player r])
      (displayln `[,(match-name names players a-player) placed ,(place (+ p 1))]))))

#; {[Listof String] [Listof Player] Player -> String}
#; {ASSUME (= (length names) (length players))}
(define (match-name names players f)
  (if (is-a? f human%)
      "the Human"
      (for/first ([p players][n names] #:when (equal? f p)) n)))
      
#; {N -> String}
(define (place p)
  (case p
    [(1) "first"]
    [(2) "second"]
    [(3) "third"]
    [(4) "last"]
    [else (~a p "th")]))
 
#; {String -> Hash}
(define (parse-args n)
  (define k (string-join n " "))
  (define h 
    (cond
      [(regexp-match #px"--file (.*)" k)
       =>
       [match-lambda
         [(list _ name)
          (with-input-from-file name read-json)]]]
      [else
       (to-hash k)]))
  (define player# (check-player# (dict-ref h 'players 2)))
  (define rows    (check-rows    (dict-ref h 'rows    6)))
  (define cols    (check-cols    (dict-ref h 'columns 6)))
  (define fish    (check-fish    (dict-ref h 'fish    2)))
  (values player# rows cols fish))

#; {N N FormatString -> X -> N}
(define ((check-xyz low high err) w)
  (unless (and (natural? w) (<= low w high)) ;; hardwired for now 
    (error 'xobserve err w))
  w)

(define (check-list w)
  (if (list? w) w #false))

(define check-player# (or/c check-list (check-xyz 2 4 "number of players expected, given ~e")))
(define check-rows    (check-xyz 2 9 "number of rows expected, given ~e"))
(define check-cols    (check-xyz 2 9 "number of columns expected, given ~e"))
(define check-fish    (check-xyz 1 5 "number of fish per tile expected, given ~e"))
(define check-depth   (check-xyz 1 3 "exploration depth expected, given ~e"))

#; {String -> Hash}
(define (to-hash x)
  (define not-in ".")
  (let* ([x (regexp-replace* #px"\\ *=\\ *" x not-in)]
         [x (~a "(" x ")")]
         [x (regexp-replace* #px"\\ +" x ")(")]
         [x (regexp-replace* (pregexp (~a "\\" not-in)) x " . ")])
    (define l (with-input-from-string x port->list))
    (make-hasheq (if (equal? '(()) l) '[] l))))
